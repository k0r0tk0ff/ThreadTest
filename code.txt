----------------  ForkJoin -----------------------------------------------------

public static void main(String[] args) {
        Main main = new Main();
        main.parallel();
    }

    void parallel() {
        int result = IntStream.range(0,3)
                .parallel()
                .peek(
                        x -> System.out.printf(
                                "Thread [%s] peek: %d\n",
                                Thread.currentThread().getName(), x))
                .sum();
        System.out.println("sum: " + result);
    }
    
-----------------  Interrupt -----------------------------------------------------    
public class Engine implements Runnable {
    public Thread thread;
    private int n;

    public Engine(int n) {
        this.thread = new Thread(this, "Engine");
        this.n = n;
    }

    public void run() {
        for (int i=1; i < 100; i++) {
            System.out.println(i);
            if(i==n) {
                thread.show.interrupt();
             }

            if(thread.isInterrupted()) {
                System.out.println("suspresume block \"is interrupted\"");
                try {
                    throw new InterruptedException("interrupted!!!");
                } catch (InterruptedException e) {
                    System.out.println("interrupted!!!");
                }
                break;
            }
        }
    }
}

public class Starter {
    public static void main(String[] args) {
        Engine engine = new Engine(5);
        engine.thread.start();
    }
}
----------------------------------------------------------------------------------------------

public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(8);
        Counter counter = new Counter();
        long start = System.nanoTime();

        List<Future<Double>> futures = new ArrayList<>();
        for (int i = 0; i < 400 ; i++) {
            final int j = i;
            futures.add(
                    CompletableFuture.supplyAsync(
                            () -> counter.count(j), threadPool
                    )
            );
        }

        double value = 0;
        for (Future<Double> future : futures ) {
            value += future.get();
        }

        System.out.println(String.format("Exe by %d s, value: %f",
                (System.nanoTime() - start)/(1000000000), value));

        threadPool.shutdown();

    }   
    
    public class Counter {
    public Double count(double a) {
        for (int i=0; i<1000000; i++) {
            a = a + Math.tan(a);
        }
        return a;
    }
}
    
    
